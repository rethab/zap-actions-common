import fs from 'fs';
import { getOctokit, context } from '@actions/github';
import {readPreviousReport, uploadArtifacts} from './action-helper';
import {findOpenIssue, findPreviousRunnerId} from './github-issues';

export async function processReport(token: string, workSpace: string, plugins: [], currentRunnerID: number, issueTitle: string, repoName: string, allowIssueWriting = true, artifactName = 'zap_scan') {
    let jsonReportName = 'report_json.json';
    let mdReportName = 'report_md.md';
    let htmlReportName = 'report_html.html';

    if (!allowIssueWriting) {
        await uploadArtifacts(workSpace, mdReportName, jsonReportName, htmlReportName);
        return;
    }

    let currentReport;
    let previousRunnerID;
    let previousReport = {};
    let create_new_issue = false;

    // Forward variable declarations
    const { owner, repo } = context.repo;
    const octokit = await getOctokit(token);

    try {
        let jReportFile = fs.readFileSync(`${workSpace}/${jsonReportName}`);
        currentReport = JSON.parse(jReportFile);
    } catch (e) {
        console.log('Failed to locate the json report generated by ZAP Scan!');
        return
    }

    const openIssue = findOpenIssue(octokit, context, issueTitle);

    // If there is no existing open issue then create a new issue
    if (openIssue === undefined) {
        create_new_issue = true;
    } else {
        previousRunnerID = await findPreviousRunnerId(openIssue)

        if (previousRunnerID) {
                previousReport = await readPreviousReport(octokit, owner, repo, workSpace, previousRunnerID);
                if (previousReport === undefined) {
                    create_new_issue = true;
                }
        }
    }


    if (plugins.length !== 0) {
        console.log(`${plugins.length} plugins will be ignored according to the rules configuration`);
        currentReport = await actionHelper.filterReport(currentReport, plugins);

        // Update the newly filtered report
        fs.unlinkSync(`${workSpace}/${jsonReportName}`);
        fs.writeFileSync(`${workSpace}/${jsonReportName}`, JSON.stringify(currentReport));
        console.log('The current report is updated with the ignored alerts!')
    }

    let newAlertExits = actionHelper.checkIfAlertsExists(currentReport);

    console.log(`Alerts present in the current report: ${newAlertExits}`);

    if (!newAlertExits) {
        // If no new alerts have been found close the issue
        console.log('No new alerts have been identified by the ZAP Scan');
        if (openIssue != null && openIssue.state === 'open') {
            // close the issue with a comment
            console.log(`Starting to close the issue #${openIssue.number}`);
            try{
                await octokit.issues.createComment({
                    owner: owner,
                    repo: repo,
                    issue_number: openIssue.number,
                    body: 'All the alerts have been resolved during the last ZAP Scan!'
                });
                await octokit.issues.update({
                    owner: owner,
                    repo: repo,
                    issue_number: openIssue.number,
                    state: 'closed'
                });
                console.log(`Successfully closed the issue #${openIssue.number}`);
            }catch (err) {
                console.log(`Error occurred while closing the issue with a comment! err: ${err}`)
            }
        }else if (openIssue != null && openIssue.state === 'closed') {
            console.log('No alerts found by ZAP Scan and no active issue is found in the repository, exiting the program!');
        }
        return;
    }

    let runnerInfo = `RunnerID:${currentRunnerID}`;
    let runnerLink = `View the [following link](${context.serverUrl}/${owner}/${repo}/actions/runs/${currentRunnerID})` +
        ` to download the report.`;
    if (create_new_issue) {

        let msg = actionHelper.createMessage(currentReport['site'], runnerInfo, runnerLink);
        const newIssue = await octokit.issues.create({
            owner: owner,
            repo: repo,
            title: issueTitle,
            body: msg
        });
        console.log(`Process completed successfully and a new issue #${newIssue.data.number} has been created for the ZAP Scan.`);

    } else {

        let siteClone = actionHelper.generateDifference(currentReport, previousReport);
        if (currentReport.updated) {
            console.log('The current report has changes compared to the previous report');
            try{
                let msg = actionHelper.createMessage(siteClone, runnerInfo, runnerLink);
                await octokit.issues.createComment({
                    owner: owner,
                    repo: repo,
                    issue_number: openIssue['number'],
                    body: msg
                });

                console.log(`The issue #${openIssue.number} has been updated with the latest ZAP scan results!`);
                console.log('ZAP Scan process completed successfully!');
            }catch (err) {
                console.log(`Error occurred while updating the issue #${openIssue.number} with the latest ZAP scan: ${err}`)
            }

        } else {
            console.log('No changes have been observed from the previous scan and current scan!, exiting the program!')
        }
    }

    await actionHelper.uploadArtifacts(workSpace, mdReportName, jsonReportName, htmlReportName, artifactName);

}
